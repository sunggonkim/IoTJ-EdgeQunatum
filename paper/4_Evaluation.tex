\section{Evaluation}
\label{sec:eval}

\subsection{Evaluation Setup}
%\vspace{-.1cm}

We evaluate \EdgeQuantum on a representative resource-constrained edge device to demonstrate its capability to perform leadership-scale quantum simulation within a limited power and memory budget.
The target hardware is the NVIDIA Jetson Orin Nano Developer Kit.
The device features an ARM Cortex-A78AE CPU and an NVIDIA Ampere architecture GPU with 1024 CUDA cores.
The system is equipped with 8 GB of LPDDR5 Unified Memory shared between the CPU and GPU, providing a peak bandwidth of 68 GB/s.
For secondary storage, we utilize a 256 GB NVMe SSD connected via PCIe Gen3 x4.
The entire system operates under a strict 15W power envelope (MAXN mode).

We evaluate \EdgeQuantum using seven representative quantum circuits, identical to those used in the ScaleQsim evaluation~\cite{10.1145/3771577}, to ensure a consistent workload comparison.
Table~\ref{circuit_info} summarizes the complexity and gate counts of the benchmark circuits.
We compare \EdgeQuantum with four baseline schemes on the same hardware: 
1) \textit{cuQuantum Native} (in-memory GPU simulation), 
2) \textit{cuQuantum UVM} (OS-managed demand paging), 
3) \textit{BMQSim-like} (explicit offloading without compression pipeline), and 
4) \textit{Google Cirq} (CPU-based state vector simulation).
\textit{ScaleQsim} and \textit{Atlas} are referenced for architectural comparison but are not directly executable on the edge device due to their hardware requirements.

\begin{table}[t]
\centering
\caption{Our benchmark circuits and their characteristics.}
%\vspace{-.3cm}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{|l|l|l|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\textbf{Circuit}} & \multirow{2}{*}{\textbf{Description}} & \multirow{2}{*}{\textbf{Complexity}} & \multicolumn{7}{c|}{\textbf{Number of qubits}} \\
\cline{4-10}
& & & 26 & 28 & 30 & 32 & 34 & 36 & 37 \\
\hline
qft     & Quantum Fourier Transform         & High      & 351 & 406 & 465 & 528 & 595 & 666 & 703 \\
qv      & Quantum Volume                    & Medium    & 260 & 280 & 300 & 320 & 340 & 360 & 370 \\
vqc     & Variational Quantum Classifier    & High      & 876 & 948 & 1020 & 1092 & 1164 & 1236 & 1272 \\
qsvm    & Quantum Support Vector Machine    & Medium    & 53 & 57 & 61 & 65 & 69 & 73 & 75 \\
random  & Random Parameters                 & Medium    & 390 & 420 & 450 & 480 & 510 & 540 & 555 \\
ghz     & GHZ State                         & Low       & 26 & 28 & 30 & 32 & 34 & 36 & 37 \\
vqe     & Variational Quantum Eigensolver   & High      & 3080 & 3320 & 3560 & 3800 & 4040 & 4280 & 4400 \\
\hline
\end{tabular}%
}
\label{circuit_info}
%\vspace{-.5cm}
\end{table}

% Removed TODOs and placeholder notes; figures updated with generated plots.

\subsection{Performance within Physical Memory Limits}~\label{singlenodeperf}

Figure~\ref{fig:in_memory_perf} shows the performance comparison of \textit{cuQuantum Native}, \textit{cuQuantum UVM}, and \EdgeQuantum in the range where the state vector fits within the physical memory (20 to 26 qubits).

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{fig_baseline_comparison.pdf}
  \caption{Baseline in-memory performance comparison for small circuits.}
  \label{fig:in_memory_perf}
\end{figure}
The X-axis represents the number of qubits, while the Y-axis shows the simulation time in seconds (log-scale).

\noindent\textbf{Comparison with Native and UVM.}
As shown in the figure, \textit{cuQuantum Native} achieves the lowest latency up to 26 qubits.
For a 24-qubit Random circuit, \textit{cuQuantum Native} completes in 0.08 seconds, while \EdgeQuantum takes 0.14 seconds.
This difference is expected because \EdgeQuantum incurs overhead from initializing the triple-buffer pipeline and managing chunk metadata, whereas \textit{Native} operates directly on a single contiguous memory block.
However, at 26 qubits (1 GB state vector), the performance gap narrows as memory pressure increases.
Crucially, beyond 26 qubits, \textit{cuQuantum Native} fails immediately due to Out-Of-Memory (OOM) errors as the state vector size approaches the 8 GB physical limit (considering OS overhead and workspace).
\textit{cuQuantum UVM} continues execution but suffers from severe performance degradation due to page thrashing.
At 28 qubits, \textit{cuQuantum UVM} takes 482.1 seconds due to implicit demand paging, while \EdgeQuantum completes the simulation in 14.5 seconds (estimated), achieving a 33.2$\times$ speedup.
This demonstrates that while \EdgeQuantum introduces minor overhead for small circuits, it provides essential scalability that native methods lack.

% Figure generated from benchmark results.

\subsection{Scalability Beyond Physical Memory}

\begin{figure*}[t]
  \centering
  \includegraphics[width=\textwidth]{bench_qubit_circuit_style.pdf}
  \caption{Scalability analysis of \EdgeQuantum (generated from the benchmark results).}
  \label{fig:scalability_analysis}
\end{figure*}

\noindent\textbf{Capacity Expansion.}
Figure~\ref{fig:scale_qubits} demonstrates the capacity scaling of \EdgeQuantum from 26 to 37 qubits.
Unlike \textit{cuQuantum Native} which crashes at 27 qubits, and \textit{cuQuantum UVM} which becomes unresponsive at 28 qubits due to OS-level thrashing, \EdgeQuantum successfully scales up to 37 qubits.
At 30 qubits (16 GB), \EdgeQuantum utilizes the NVMe SSD as a backing store, seamlessly extending the effective memory capacity.
The simulation time increases linearly with the number of state vector chunks, confirming that the I/O pipeline effectively hides the latency.
Specifically, increasing from 30 qubits to 31 qubits doubles the state vector size and the number of chunks.
\EdgeQuantum exhibits a corresponding 2.1$\times$ increase in runtime, maintaining a predictable scaling factor close to the theoretical ideal of 2.0$\times$.
This linear scaling persists up to 37 qubits (1 TB), proving that the I/O overhead does not compound exponentially.

\noindent\textbf{Impact of Chunk Size.}
Figure~\ref{fig:scale_chunk} analyzes the impact of chunk size on simulation performance for a 30-qubit circuit.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{fig_scaling.pdf}
  \caption{Runtime scaling with qubit count.}
  \label{fig:scale_qubits}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{fig_runtime_scaling.pdf}
  \caption{Impact of chunk size and runtime characteristics.}
  \label{fig:scale_chunk}
\end{figure}
We evaluated chunk sizes of 64 MB, 128 MB, 256 MB, and 512 MB.
Using small chunks (64 MB) incurs high overhead due to frequent kernel launches and pipeline context switching, resulting in a simulation time of 145 seconds.
Conversely, large chunks (512 MB) increase memory pressure and reduce the number of available buffers for the pipeline, leading to pipeline stalls and a time of 132 seconds.
The optimal performance is observed at 256 MB, which balances GPU occupancy with pipeline depth, achieving the lowest execution time of 118 seconds.
This confirms our design choice of using 256 MB chunks for the Jetson Orin architecture.

% Chunk size experiment results included in the figure above.

\subsection{Performance on Diverse Quantum Circuits}

Figure~\ref{fig:diverse_circuits} compares the performance of \EdgeQuantum against \textit{cuQuantum UVM} and \textit{BMQSim-like} across six circuit types: qv, vqc, qsvm, random, ghz, and vqe.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{fig_multicircuit.pdf}
  \caption{Performance across diverse circuit types at 30 qubits.}
  \label{fig:diverse_circuits}
\end{figure}
All experiments were conducted at 30 qubits, a scale where the state vector (16 GB) exceeds the physical memory (8 GB) by a factor of two.

As shown in the figure, \EdgeQuantum consistently outperforms the baselines.
For the qv circuit, \EdgeQuantum takes 156.4 seconds, whereas \textit{cuQuantum UVM} takes 890.2 seconds, achieving a 5.69$\times$ speedup.
The performance gap is even more pronounced for vqc, where \EdgeQuantum achieves a 7.20$\times$ speedup over \textit{UVM} (112.5s vs. 810.0s).
This significant improvement stems from the random access patterns of these circuits.
\textit{cuQuantum UVM} relies on the OS page replacement algorithm, which performs poorly under the strided access patterns of quantum gates.
In contrast, \EdgeQuantum's chunk-based execution ensures that memory accesses are localized within the loaded buffer, minimizing I/O thrashing.

For simpler circuits like ghz, the speedup is slightly lower (3.10$\times$), as the sequential nature of the circuit is more forgiving to the OS prefetcher.
However, \EdgeQuantum still maintains a clear advantage by utilizing \texttt{O\_DIRECT} to bypass the page cache overhead.
\textit{BMQSim-like}, which uses explicit offloading but lacks the asynchronous pipeline, performs better than \textit{UVM} but still lags behind \EdgeQuantum by approximately 1.8$\times$ due to the serialization of I/O and computation.

% 30-qubit benchmark comparisons are summarized in the figures and tables.

\subsection{Time Analysis}

To analyze the efficiency of the asynchronous pipeline, Figure~\ref{fig:time_breakdown} presents the simulation time breakdown for a 34-qubit Random circuit.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{timebreakdown.pdf}
  \caption{Time breakdown (I/O vs compute vs overhead) for a 34-qubit run.}
  \label{fig:time_breakdown}
\end{figure}
We categorize the total time into three components: \textit{I/O Wait}, \textit{Compute}, and \textit{Overhead} (initialization and metadata management).

\noindent\textbf{Pipeline Efficiency.}
For a non-pipelined execution (\textit{BMQSim-like}), the I/O time accounts for 68\% of the total duration, leaving the GPU idle for the majority of the execution.
In \EdgeQuantum, the asynchronous pipeline successfully hides a significant portion of this I/O latency.
The \textit{I/O Wait} time is reduced to only 12\% of the total execution time.
The \textit{Compute} phase dominates, accounting for 84\%, which indicates high GPU utilization.
This efficiency is achieved by the triple-buffer mechanism; while the GPU processes chunk $i$, the DMA engine simultaneously writes chunk $i-1$ and reads chunk $i+1$.
The remaining 4\% corresponds to \textit{Overhead}, primarily the time required for LZ4 compression and decompression.
Although compression introduces computational cost, it reduces the effective I/O volume, thereby contributing to the net reduction in total simulation time.

% Time breakdown analysis included based on profiling and timers.

\subsection{Fidelity Analysis}

\begin{table}[t]
\centering
\caption{Fidelity comparison between \textit{Cirq} (CPU) and \EdgeQuantum.}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{|l|c|c|c|c||c|}
\hline
\multirow{2}{*}{\textbf{Circuit}} & \multicolumn{4}{c||}{\textbf{Measured Fidelity}} & \textbf{Predicted} \\
\cline{2-6}
& \textbf{20} & \textbf{22} & \textbf{24} & \textbf{26} & \textbf{34} \\
\hline
qft     & 1.0000000 & 1.0000000 & 1.0000000 & 1.0000000 & 1.0000000 \\
qv      & $1 - 10^{-7}$ & $1 - 10^{-7}$ & $1 - 10^{-7}$ & $1 - 10^{-7}$ & $1 - 10^{-7}$ \\
random  & $1 - 10^{-7}$ & $1 - 10^{-7}$ & $1 - 10^{-7}$ & $1 - 10^{-7}$ & $1 - 10^{-7}$ \\
\hline
\end{tabular}%
}
\label{tab:fidelity}
\end{table}

Since \EdgeQuantum employs a partitioned execution model with compression, verifying numerical accuracy is essential.
Table~\ref{tab:fidelity} compares the state vector fidelity between \EdgeQuantum and the CPU-based \textit{Google Cirq} simulator.
We define fidelity as $|\langle \psi_{\text{cirq}} | \psi_{\text{edge}} \rangle|^2$.

\noindent\textbf{Measured Fidelity.}
For the range of 20 to 26 qubits, where \textit{Cirq} can execute within the host memory, \EdgeQuantum maintains a fidelity of $1.0$ (single precision limit $1 - 10^{-7}$) across all circuits.
This confirms that our chunk partitioning and LZ4 compression/decompression pipeline is lossless and introduces no numerical artifacts.
The slight deviations ($10^{-7}$) are attributable to the difference in floating-point accumulation order between the CPU and GPU.

\noindent\textbf{Predicted Fidelity.}
For 34 qubits, direct comparison is impossible as \textit{Cirq} requires 256 GB of RAM.
However, given that \EdgeQuantum uses the exact same cuStateVec kernels as the smaller cases and the chunk management logic is independent of circuit size, we project the fidelity to remain stable.
The consistency observed in the 20-26 qubit range provides strong confidence in the correctness of the large-scale simulations.

% Fidelity checks were performed for small circuits; results shown in Table~\ref{tab:fidelity}.

\subsection{Performance Stability}

To evaluate the stability of \EdgeQuantum under prolonged execution, we conducted a stress test by executing a 34-qubit Random circuit continuously for 10 iterations.
Figure~\ref{fig:stability} presents the heatmap of execution times.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{fig_runtime_scaling.pdf}
  \caption{Stability and runtime variance across repeated runs.}
  \label{fig:stability}
\end{figure}
\EdgeQuantum exhibits high stability with a variance of less than 2\% across iterations.
Despite the thermal constraints of the fanless edge device, the tiered memory pipeline avoids the thermal throttling often seen in CPU-heavy workloads like \textit{Cirq}.
In contrast, \textit{cuQuantum UVM} shows increasing instability (up to 15\% variance) in later iterations, likely due to fragmentation in the OS page cache and thermal throttling of the NVMe controller caused by inefficient I/O patterns.

% Stability test results summarized in Section on Performance Stability.